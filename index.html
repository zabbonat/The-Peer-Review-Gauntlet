<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Peer Review Gauntlet: Dream Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 2px 2px #000;
            font-size: 20px;
            z-index: 10;
            display: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 30px;
        }

        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #fff;
            color: #fff;
            padding: 20px;
            display: none;
            z-index: 100;
            font-size: 16px;
            line-height: 1.5;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="loading">LOADING ASSETS...</div>
    <div id="ui">
        <div>SCORE: <span id="score">0</span></div>
        <div>LIVES: <span id="lives">3</span></div>
    </div>
    <div id="dialogue-box"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- ASSETS ---
        const assets = {
            researcherRun: new Image(),
            researcherJump: new Image(),
            researcherSpin: new Image(),
            enemy1: new Image(),
            enemy2: new Image(),
            enemy3: new Image(),
            introBg: new Image(),
            dreamBg: new Image()
        };
        let assetsLoaded = 0;

        function loadAsset(name, src) {
            assets[name].src = src;
            assets[name].onload = () => {
                assetsLoaded++;
                if (assetsLoaded === 8) startGame();
            };
            assets[name].onerror = () => {
                console.error("Failed to load asset: " + src);
                // alert("Error loading asset: " + src);
            };
        }

        loadAsset('researcherRun', 'assets/researcher_run.png');
        loadAsset('researcherJump', 'assets/researcher_jump.png');
        loadAsset('researcherSpin', 'assets/researcher_spin.png');
        loadAsset('enemy1', 'assets/enemy1.png');
        loadAsset('enemy2', 'assets/enemy2.png');
        loadAsset('enemy3', 'assets/enemy3.png');
        loadAsset('introBg', 'assets/intro_bg.png');
        loadAsset('dreamBg', 'assets/dream_bg.png');

        // --- GAME STATE ---
        let gameState = 'LOADING'; // LOADING, INTRO, PLAYING, GAMEOVER
        let frame = 0;
        let score = 0;
        let lives = 3;

        // --- INPUT ---
        const keys = { left: false, right: false, jump: false, spin: false };
        window.addEventListener('keydown', e => {
            if (e.code === 'KeyA' || e.code === 'ArrowLeft') changeLane(-1);
            if (e.code === 'KeyD' || e.code === 'ArrowRight') changeLane(1);
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                if (gameState === 'INTRO') advanceIntro();
                else jump();
            }
            if (e.code === 'KeyK' || e.code === 'ShiftLeft') spin();
        });

        // --- INTRO SEQUENCE ---
        let introStep = 0;
        const introLines = [
            { text: "PROFESSOR: 'Excellent work. The manuscript is ready.'", bg: 'introBg' },
            { text: "PROFESSOR: 'But beware... Reviewer 2 is in a bad mood today.'", bg: 'introBg' },
            { text: "RESEARCHER: 'I'll just take a quick nap before submitting...'", bg: 'introBg' },
            { text: "*ENTERING THE NIGHTMARE REALM*", bg: 'dreamBg' }
        ];

        function advanceIntro() {
            introStep++;
            if (introStep >= introLines.length) {
                gameState = 'PLAYING';
                document.getElementById('dialogue-box').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                initGame();
            } else {
                showDialogue(introLines[introStep].text);
            }
        }

        function showDialogue(text) {
            const box = document.getElementById('dialogue-box');
            box.innerText = text + "\n\n[PRESS SPACE]";
            box.style.display = 'block';
        }

        // --- 3D RUNNER ENGINE ---
        const FOV = 300;
        const CAMERA_Y = 150;
        const LANE_WIDTH = 140;
        const DRAW_DISTANCE = 3000;
        let worldZ = 0;
        let speed = 20;

        const player = { lane: 0, x: 0, y: 0, vy: 0, isJumping: false, isSpinning: false, spinTimer: 0, targetX: 0 };
        let objects = [];

        function initGame() {
            objects = [];
            worldZ = 0;
            score = 0;
            lives = 3;
            player.lane = 0;
            // Spawn initial objects
            for (let z = 1000; z < DRAW_DISTANCE; z += 500) spawnObject(z);
        }

        function changeLane(dir) {
            if (gameState !== 'PLAYING') return;
            player.lane += dir;
            if (player.lane < -1) player.lane = -1;
            if (player.lane > 1) player.lane = 1;
            player.targetX = player.lane * LANE_WIDTH;
        }

        function jump() {
            if (gameState !== 'PLAYING') return;
            if (!player.isJumping) { player.vy = -25; player.isJumping = true; }
        }

        function spin() {
            if (gameState !== 'PLAYING') return;
            if (!player.isSpinning) { player.isSpinning = true; player.spinTimer = 30; }
        }

        function spawnObject(z) {
            const lane = Math.floor(Math.random() * 3) - 1;
            const r = Math.random();
            let type = 'crate';
            let subtype = ''; // For enemies

            if (r > 0.6) {
                type = 'enemy';
                // Random enemy subtype
                const rand = Math.random();
                if (rand < 0.33) subtype = 'enemy1';
                else if (rand < 0.66) subtype = 'enemy2';
                else subtype = 'enemy3';
            } else {
                type = 'crate';
            }

            objects.push({ type, subtype, lane, z, active: true });
        }

        function project(x, y, z) {
            const scale = FOV / (FOV + z);
            return {
                x: (x * scale) + canvas.width / 2,
                y: ((y - CAMERA_Y) * scale) + canvas.height / 2,
                scale: scale
            };
        }

        function update() {
            worldZ += speed;
            player.x += (player.targetX - player.x) * 0.2;

            if (player.isJumping) {
                player.y += player.vy;
                player.vy += 1.5;
                if (player.y >= 0) { player.y = 0; player.vy = 0; player.isJumping = false; }
            }

            if (player.isSpinning) {
                player.spinTimer--;
                if (player.spinTimer <= 0) player.isSpinning = false;
            }

            // Spawn & Cleanup
            if (objects.length > 0 && objects[objects.length - 1].z < DRAW_DISTANCE - 400) spawnObject(objects[objects.length - 1].z + 500);
            objects = objects.filter(obj => obj.z - worldZ > -200);

            // Collisions
            objects.forEach(obj => {
                if (!obj.active) return;
                const relZ = obj.z - worldZ;
                if (Math.abs(relZ) < 50 && Math.abs(player.x - obj.lane * LANE_WIDTH) < 50) {
                    if (obj.type === 'enemy') {
                        if (player.isSpinning) {
                            obj.active = false; score += 100;
                        } else {
                            lives--;
                            obj.active = false;
                            if (lives <= 0) alert("GAME OVER");
                        }
                    } else {
                        obj.active = false; score += 10;
                    }
                    document.getElementById('score').innerText = score;
                    document.getElementById('lives').innerText = lives;
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'LOADING') {
                return;
            }

            if (gameState === 'INTRO') {
                // Draw Intro Background
                const bg = assets[introLines[introStep].bg];
                if (bg.complete) {
                    const scale = Math.max(canvas.width / bg.width, canvas.height / bg.height);
                    const w = bg.width * scale;
                    const h = bg.height * scale;
                    ctx.drawImage(bg, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
                }
                return;
            }

            if (gameState === 'PLAYING') {
                // Draw Dream Background (Parallax)
                const bg = assets.dreamBg;
                if (bg.complete) {
                    const scale = Math.max(canvas.width / bg.width, canvas.height / bg.height);
                    ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
                }

                // Draw Objects
                const visibleObjects = objects.filter(obj => obj.active && obj.z - worldZ > 0);
                visibleObjects.sort((a, b) => b.z - a.z);

                visibleObjects.forEach(obj => {
                    const relZ = obj.z - worldZ;
                    const p = project(obj.lane * LANE_WIDTH, 0, relZ);
                    const s = p.scale * 200; // Base size

                    if (obj.type === 'enemy') {
                        // Draw specific enemy sprite
                        const sprite = assets[obj.subtype];
                        if (sprite && sprite.complete) {
                            ctx.drawImage(sprite, p.x - s / 2, p.y - s, s, s);
                        } else {
                            // Fallback
                            ctx.fillStyle = 'red';
                            ctx.fillRect(p.x - s / 2, p.y - s, s, s);
                        }
                    } else {
                        // Crate
                        ctx.fillStyle = 'orange';
                        ctx.fillRect(p.x - s / 2, p.y - s, s, s);
                    }
                });

                // Draw Player
                const pScale = 1.0; // Player is at Z=0
                const px = canvas.width / 2 + player.x;
                const py = canvas.height / 2 - CAMERA_Y + player.y + 100; // Offset
                const ps = 200;

                ctx.save();
                let sprite;
                if (player.isSpinning) {
                    sprite = assets.researcherSpin;
                    // Spin rotation effect
                    ctx.translate(px, py);
                    ctx.rotate(frame * 0.5);
                    ctx.drawImage(sprite, -ps / 2, -ps / 2, ps, ps);
                } else {
                    if (player.isJumping) {
                        sprite = assets.researcherJump;
                    } else {
                        sprite = assets.researcherRun;
                    }
                    // Bobbing effect for run
                    let bobY = 0;
                    if (!player.isJumping) bobY = Math.sin(frame * 0.5) * 10;

                    ctx.drawImage(sprite, px - ps / 2, py - ps + bobY, ps, ps);
                }
                ctx.restore();
            }
        }

        function startGame() {
            document.getElementById('loading').style.display = 'none';
            gameState = 'INTRO';
            showDialogue(introLines[0].text);
            loop();
        }

        function loop() {
            frame++;
            if (gameState === 'PLAYING') update();
            draw();
            requestAnimationFrame(loop);
        }
    </script>
</body>

</html>