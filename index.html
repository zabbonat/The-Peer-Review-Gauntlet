<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crash the Reviewers ü¶ä</title>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Bangers', cursive;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff9f43;
            text-shadow: 3px 3px #d35400;
            font-size: 30px;
            pointer-events: none;
            z-index: 10;
            display: flex;
            gap: 20px;
        }

        #wumpa-counter {
            color: #e67e22;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #e67e22 0%, #d35400 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 200;
        }

        h1 {
            font-size: 80px;
            margin: 0;
            text-shadow: 5px 5px #000;
            transform: rotate(-5deg);
        }

        button {
            font-family: 'Bangers', cursive;
            padding: 20px 50px;
            font-size: 30px;
            background: #2ecc71;
            color: #fff;
            border: 5px solid #fff;
            cursor: pointer;
            margin-top: 50px;
            box-shadow: 0 10px #27ae60;
            transition: transform 0.1s;
        }

        button:hover {
            transform: scale(1.1);
        }

        button:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="wumpa-counter">üçé <span id="score">0</span></div>
        <div>‚ù§Ô∏è <span id="lives">3</span></div>
    </div>

    <div id="start-screen">
        <h1>CRASH THE<br>REVIEWERS</h1>
        <p style="font-size: 24px; text-shadow: 2px 2px #000;">A / D to Move | SPACE to Jump | K to SPIN!</p>
        <button onclick="startGame()">WOAH!</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 3D ENGINE CONSTANTS ---
        const FOV = 300; // Field of View / Focal Length
        const CAMERA_Y = 150; // Camera height
        const CAMERA_Z = -300; // Camera distance behind player
        const LANE_WIDTH = 120;
        const SEGMENT_LENGTH = 100;
        const DRAW_DISTANCE = 3000;

        // --- GAME STATE ---
        let gameState = 'START';
        let score = 0;
        let lives = 3;
        let frame = 0;
        let speed = 15;
        let worldZ = 0; // How far we've run

        // --- INPUT ---
        const keys = { left: false, right: false, jump: false, spin: false };
        window.addEventListener('keydown', e => {
            if (e.code === 'KeyA' || e.code === 'ArrowLeft') changeLane(-1);
            if (e.code === 'KeyD' || e.code === 'ArrowRight') changeLane(1);
            if (e.code === 'Space' || e.code === 'ArrowUp') jump();
            if (e.code === 'KeyK' || e.code === 'ShiftLeft') spin();
        });

        // --- PLAYER ---
        const player = {
            lane: 0, // -1 (Left), 0 (Center), 1 (Right)
            x: 0, // Interpolated X
            y: 0, // Y (Jump)
            z: 0, // Fixed Z relative to camera logic
            vy: 0,
            isJumping: false,
            isSpinning: false,
            spinTimer: 0,
            targetX: 0
        };

        function changeLane(dir) {
            if (gameState !== 'PLAYING') return;
            player.lane += dir;
            if (player.lane < -1) player.lane = -1;
            if (player.lane > 1) player.lane = 1;
            player.targetX = player.lane * LANE_WIDTH;
        }

        function jump() {
            if (gameState !== 'PLAYING') return;
            if (!player.isJumping) {
                player.vy = -25;
                player.isJumping = true;
            }
        }

        function spin() {
            if (gameState !== 'PLAYING') return;
            if (!player.isSpinning) {
                player.isSpinning = true;
                player.spinTimer = 20; // Frames
            }
        }

        // --- OBJECTS ---
        let objects = []; // { type, lane, z, active }

        function spawnObject(z) {
            const lane = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
            const r = Math.random();
            let type = 'crate';

            if (r > 0.8) type = 'enemy';
            else if (r > 0.6) type = 'tnt';
            else if (r > 0.4) type = 'pit';
            else type = 'crate';

            objects.push({ type, lane, z, active: true, width: 60, height: 60 });
        }

        function initLevel() {
            objects = [];
            worldZ = 0;
            score = 0;
            lives = 3;
            player.lane = 0;
            player.x = 0;
            player.targetX = 0;

            // Pre-spawn some objects
            for (let z = 500; z < DRAW_DISTANCE; z += 400) {
                spawnObject(z);
            }
        }

        // --- PROJECTION ---
        function project(x, y, z) {
            const scale = FOV / (FOV + z);
            const x2d = (x * scale) + canvas.width / 2;
            const y2d = ((y - CAMERA_Y) * scale) + canvas.height / 2;
            return { x: x2d, y: y2d, scale: scale };
        }

        // --- DRAWING ---
        function drawRect3D(x, y, z, w, h, color) {
            const p = project(x, y, z);
            const scaledW = w * p.scale;
            const scaledH = h * p.scale;

            // Simple depth shading
            ctx.globalAlpha = Math.max(0.2, Math.min(1, 1 - (z / DRAW_DISTANCE)));
            ctx.fillStyle = color;
            ctx.fillRect(p.x - scaledW / 2, p.y - scaledH, scaledW, scaledH);
            ctx.globalAlpha = 1.0;
        }

        function drawSprite3D(type, x, y, z, w, h) {
            const p = project(x, y, z);
            const sw = w * p.scale;
            const sh = h * p.scale;

            if (p.scale <= 0) return; // Behind camera

            ctx.save();
            ctx.translate(p.x, p.y);

            if (type === 'player') {
                // Crash-like
                if (player.isSpinning) {
                    ctx.rotate(frame * 1.5); // Spin effect
                    ctx.fillStyle = '#e67e22'; // Orange blur
                    ctx.beginPath();
                    ctx.arc(0, -sh / 2, sw, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Body
                    ctx.fillStyle = '#e67e22'; // Orange Fur
                    ctx.fillRect(-sw / 2, -sh, sw, sh);
                    // Pants
                    ctx.fillStyle = '#2980b9'; // Blue Jeans
                    ctx.fillRect(-sw / 2, -sh / 3, sw, sh / 3);
                    // Shoes
                    ctx.fillStyle = '#c0392b'; // Red Sneakers
                    ctx.fillRect(-sw / 2, -sh / 6, sw / 2, sh / 6);
                    ctx.fillRect(0, -sh / 6, sw / 2, sh / 6);
                    // Face
                    ctx.fillStyle = '#f1c40f'; // Muzzle
                    ctx.fillRect(-sw / 4, -sh * 0.9, sw / 2, sh / 3);
                }
            } else if (type === 'crate') {
                // Wumpa Crate
                ctx.fillStyle = '#e67e22'; // Wood
                ctx.fillRect(-sw / 2, -sh, sw, sh);
                ctx.strokeStyle = '#d35400';
                ctx.lineWidth = 2;
                ctx.strokeRect(-sw / 2, -sh, sw, sh);
                // Stripes
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(-sw / 2 + 5, -sh + 5, sw - 10, sh - 10);
                // Question Mark
                ctx.fillStyle = '#fff';
                ctx.font = `${Math.floor(sh / 2)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('?', 0, -sh / 3);

            } else if (type === 'tnt') {
                ctx.fillStyle = '#c0392b'; // Red
                ctx.fillRect(-sw / 2, -sh, sw, sh);
                ctx.fillStyle = '#fff';
                ctx.font = `${Math.floor(sh / 2)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('TNT', 0, -sh / 3);

            } else if (type === 'enemy') {
                // Reviewer
                ctx.fillStyle = '#8e44ad'; // Purple suit
                ctx.fillRect(-sw / 2, -sh, sw, sh);
                // Horns
                ctx.fillStyle = '#fff';
                ctx.fillRect(-sw / 2, -sh - sh / 4, sw / 4, sh / 4);
                ctx.fillRect(sw / 4, -sh - sh / 4, sw / 4, sh / 4);

            } else if (type === 'pit') {
                ctx.fillStyle = '#000';
                // Draw flat on ground
                // Actually pits are holes, so draw black rect on floor
                // Reset transform for floor drawing logic?
                // For simplicity, draw black rect slightly below ground level
            }

            ctx.restore();
        }

        // --- LOGIC ---
        function update() {
            // Move World
            worldZ += speed;

            // Player Physics
            player.x += (player.targetX - player.x) * 0.2; // Smooth lane change

            if (player.isJumping) {
                player.y += player.vy;
                player.vy += 1.5; // Gravity
                if (player.y >= 0) {
                    player.y = 0;
                    player.vy = 0;
                    player.isJumping = false;
                }
            }

            if (player.isSpinning) {
                player.spinTimer--;
                if (player.spinTimer <= 0) player.isSpinning = false;
            }

            // Object Management
            // Spawn new
            if (objects.length > 0 && objects[objects.length - 1].z < DRAW_DISTANCE - 400) {
                spawnObject(objects[objects.length - 1].z + 400);
            }

            // Update & Collide
            objects.forEach(obj => {
                // Move towards player (relative Z)
                // Actually, we keep objects at absolute Z, and subtract worldZ for rendering
                // But for infinite runner, let's say objects have absolute Z
                // And player is at worldZ.
                // Relative Z = obj.z - worldZ
            });

            // Cleanup
            objects = objects.filter(obj => obj.z - worldZ > -200);

            checkCollisions();
        }

        function checkCollisions() {
            objects.forEach(obj => {
                if (!obj.active) return;

                const relZ = obj.z - worldZ;

                // Check Z depth (Player is at Z=0 roughly, maybe width/depth of 50)
                if (relZ < 50 && relZ > -50) {
                    // Check Lane
                    // Simple lane check: if player is close to lane center
                    const laneX = obj.lane * LANE_WIDTH;
                    if (Math.abs(player.x - laneX) < 40) {

                        // Collision!
                        if (obj.type === 'pit') {
                            if (player.y > -20) { // Not jumping high enough
                                die("Fell into the Data Gap!");
                            }
                        } else if (obj.type === 'crate') {
                            if (player.isSpinning || player.isJumping) {
                                // Break crate
                                obj.active = false;
                                score += 10;
                                document.getElementById('score').innerText = score;
                            } else {
                                // Bonk (stop player or just break it?)
                                // Crash usually breaks crates by jumping/spinning. Running into them stops you.
                                // Let's just break it for flow
                                obj.active = false;
                                score += 1;
                                document.getElementById('score').innerText = score;
                            }
                        } else if (obj.type === 'enemy') {
                            if (player.isSpinning) {
                                // Kill enemy
                                obj.active = false;
                                score += 50;
                                document.getElementById('score').innerText = score;
                            } else {
                                die("Reviewer 2 caught you!");
                            }
                        } else if (obj.type === 'tnt') {
                            if (player.isSpinning) {
                                die("Don't spin TNT!");
                            } else {
                                die("BOOM!");
                            }
                        }
                    }
                }
            });
        }

        function die(reason) {
            lives--;
            document.getElementById('lives').innerText = lives;
            if (lives <= 0) {
                alert(reason + "\nGAME OVER");
                location.reload();
            } else {
                // Respawn / Knockback
                // Just clear nearby objects
                objects.forEach(obj => {
                    if (obj.z - worldZ < 500) obj.active = false;
                });
                player.isSpinning = true; // Invincibility frames visual
                player.spinTimer = 60;
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            initLevel();
            gameState = 'PLAYING';
            loop();
        }

        function loop() {
            if (gameState === 'START') return;
            frame++;
            update();

            // Clear
            ctx.fillStyle = '#87CEEB'; // Sky
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floor (Checkerboard)
            // Draw floor segments
            const startZ = Math.floor(worldZ / SEGMENT_LENGTH) * SEGMENT_LENGTH;

            for (let z = startZ + DRAW_DISTANCE; z >= startZ; z -= SEGMENT_LENGTH) {
                const relZ = z - worldZ;
                if (relZ < 10) continue;

                const p1 = project(-LANE_WIDTH * 2.5, 0, relZ);
                const p2 = project(LANE_WIDTH * 2.5, 0, relZ);
                const p3 = project(LANE_WIDTH * 2.5, 0, relZ + SEGMENT_LENGTH);
                const p4 = project(-LANE_WIDTH * 2.5, 0, relZ + SEGMENT_LENGTH);

                // Checker color
                const segmentIndex = Math.floor(z / SEGMENT_LENGTH);
                ctx.fillStyle = segmentIndex % 2 === 0 ? '#2ecc71' : '#27ae60';

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.fill();
            }

            // Draw Objects (Back to Front)
            // Sort objects by Z (descending) so far ones draw first
            // Actually, we iterate our array. Since we spawn in increasing Z, we should iterate backwards?
            // Or just filter visible ones and sort.
            const visibleObjects = objects.filter(obj => obj.active && obj.z - worldZ > 10 && obj.z - worldZ < DRAW_DISTANCE);
            visibleObjects.sort((a, b) => b.z - a.z);

            visibleObjects.forEach(obj => {
                const relZ = obj.z - worldZ;
                const x = obj.lane * LANE_WIDTH;

                if (obj.type === 'pit') {
                    // Draw pit on floor
                    const p = project(x, 0, relZ);
                    const w = 100 * p.scale;
                    const h = 50 * p.scale; // Length on floor
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(p.x, p.y, w / 2, w / 2, 0, 0, Math.PI * 2); // Simple circle pit
                    ctx.fill();
                } else {
                    drawSprite3D(obj.type, x, player.y, relZ, obj.width, obj.height);
                }
            });

            // Draw Player
            drawSprite3D('player', player.x, player.y, 0, 60, 80);

            requestAnimationFrame(loop);
        }
    </script>
</body>

</html>