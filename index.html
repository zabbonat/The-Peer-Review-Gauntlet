<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Peer Review Gauntlet: Action Edition ⚔️</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --accent-red: #e94560;
            --accent-gold: #f1c40f;
            --accent-blue: #3498db;
            --text-primary: #ecf0f1;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-dark);
            color: var(--text-primary);
            font-family: 'VT323', monospace;
            overflow: hidden;
            user-select: none;
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid var(--accent-gold);
            padding: 10px;
            color: var(--accent-gold);
        }

        .hp-bar-container {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            margin-top: 5px;
        }

        .hp-bar-fill {
            width: 100%;
            height: 100%;
            background: var(--accent-red);
            transition: width 0.1s;
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 18px;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-red);
            font-size: 40px;
            margin-bottom: 20px;
            text-align: center;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            padding: 15px 30px;
            font-size: 16px;
            background: var(--accent-gold);
            border: none;
            cursor: pointer;
            margin-top: 20px;
        }

        button:hover {
            transform: scale(1.1);
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div id="game-ui">
        <div class="hud-bar">
            <div>
                HP
                <div class="hp-bar-container">
                    <div id="hp-bar" class="hp-bar-fill"></div>
                </div>
            </div>
            <div class="stat-box">
                SCORE: <span id="score-val">0</span>
            </div>
            <div class="stat-box">
                WAVE: <span id="wave-val">1</span>
            </div>
        </div>

        <div id="controls-hint">
            WASD to Move | SPACE to Shoot Citations | SHIFT to Shield
        </div>

        <div id="game-over" class="hidden">
            <h1 id="go-title">REJECTED</h1>
            <p id="go-msg" style="font-size: 24px;">Your paper was not robust enough.</p>
            <button onclick="resetGame()">TRY AGAIN</button>
        </div>

        <div id="start-screen"
            style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(26,26,46,1); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:200; pointer-events:auto;">
            <h1 style="color:var(--accent-gold)">THE PEER REVIEW GAUNTLET<br><span
                    style="font-size:20px; color:#fff">ACTION EDITION</span></h1>
            <p style="max-width:600px; text-align:center; font-size:20px; line-height:1.5; margin-bottom:30px;">
                You are the Manuscript.<br>
                Reviewers are coming to tear you apart.<br>
                <strong>Move</strong> with WASD.<br>
                <strong>Shoot</strong> Citations with SPACE.<br>
                <strong>Shield</strong> with SHIFT.
            </p>
            <button onclick="startGame()">START DEFENSE</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Game State
        let gameRunning = false;
        let score = 0;
        let wave = 1;
        let frame = 0;

        // Inputs
        const keys = {
            w: false, a: false, s: false, d: false,
            Space: false, Shift: false
        };

        window.addEventListener('keydown', e => {
            if (e.code === 'Space') keys.Space = true;
            if (e.code === 'ShiftLeft') keys.Shift = true;
            if (e.key.toLowerCase() === 'w') keys.w = true;
            if (e.key.toLowerCase() === 'a') keys.a = true;
            if (e.key.toLowerCase() === 's') keys.s = true;
            if (e.key.toLowerCase() === 'd') keys.d = true;
        });

        window.addEventListener('keyup', e => {
            if (e.code === 'Space') keys.Space = false;
            if (e.code === 'ShiftLeft') keys.Shift = false;
            if (e.key.toLowerCase() === 'w') keys.w = false;
            if (e.key.toLowerCase() === 'a') keys.a = false;
            if (e.key.toLowerCase() === 's') keys.s = false;
            if (e.key.toLowerCase() === 'd') keys.d = false;
        });

        // Entities
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.radius = 20;
                this.speed = 5;
                this.hp = 100;
                this.maxHp = 100;
                this.color = '#f1c40f'; // Gold manuscript
                this.lastShot = 0;
                this.shootCooldown = 15; // Frames
                this.shieldActive = false;
                this.shieldEnergy = 100;
            }

            update() {
                // Movement
                if (keys.w && this.y > this.radius) this.y -= this.speed;
                if (keys.s && this.y < canvas.height - this.radius) this.y += this.speed;
                if (keys.a && this.x > this.radius) this.x -= this.speed;
                if (keys.d && this.x < canvas.width - this.radius) this.x += this.speed;

                // Shooting
                if (keys.Space && frame - this.lastShot > this.shootCooldown) {
                    projectiles.push(new Projectile(this.x, this.y, 0, -10)); // Shoot up? No, shoot towards mouse? Or just straight?
                    // Let's shoot in direction of movement or default right if still
                    // For simplicity in this prototype: Shoot towards nearest enemy or mouse?
                    // Let's do: Shoot towards mouse.
                    // Need mouse pos.
                    // Fallback: Shoot 4-way?
                    // Let's implement mouse aiming.
                    this.lastShot = frame;
                }

                // Shield
                this.shieldActive = keys.Shift && this.shieldEnergy > 0;
                if (this.shieldActive) {
                    this.shieldEnergy -= 1;
                } else if (this.shieldEnergy < 100) {
                    this.shieldEnergy += 0.5;
                }
            }

            draw() {
                // Shield
                if (this.shieldActive) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 15, this.y - 20, 30, 40); // Paper shape

                // Lines
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - 10, this.y - 10, 20, 2);
                ctx.fillRect(this.x - 10, this.y - 0, 20, 2);
                ctx.fillRect(this.x - 10, this.y + 10, 20, 2);

                // Shield Bar
                if (this.shieldEnergy < 100) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - 20, this.y + 30, 40, 5);
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(this.x - 20, this.y + 30, 40 * (this.shieldEnergy / 100), 5);
                }
            }
        }

        // Mouse Aiming
        let mouseX = 0;
        let mouseY = 0;
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Override Player Update for Shooting
        Player.prototype.update = function () {
            // Movement
            if (keys.w && this.y > this.radius) this.y -= this.speed;
            if (keys.s && this.y < canvas.height - this.radius) this.y += this.speed;
            if (keys.a && this.x > this.radius) this.x -= this.speed;
            if (keys.d && this.x < canvas.width - this.radius) this.x += this.speed;

            // Shooting
            if (keys.Space && frame - this.lastShot > this.shootCooldown) {
                const angle = Math.atan2(mouseY - this.y, mouseX - this.x);
                const velocity = {
                    x: Math.cos(angle) * 10,
                    y: Math.sin(angle) * 10
                };
                projectiles.push(new Projectile(this.x, this.y, velocity.x, velocity.y));
                this.lastShot = frame;
            }

            // Shield
            this.shieldActive = keys.Shift && this.shieldEnergy > 0;
            if (this.shieldActive) {
                this.shieldEnergy -= 1;
            } else if (this.shieldEnergy < 100) {
                this.shieldEnergy += 0.5;
            }
        };

        class Projectile {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = 5;
                this.markedForDeletion = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.markedForDeletion = true;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }
        }

        class Enemy {
            constructor(type) {
                // Spawn at random edge
                if (Math.random() < 0.5) {
                    this.x = Math.random() < 0.5 ? -50 : canvas.width + 50;
                    this.y = Math.random() * canvas.height;
                } else {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() < 0.5 ? -50 : canvas.height + 50;
                }

                this.type = type;
                this.radius = 25;
                this.speed = 2 + Math.random();
                this.markedForDeletion = false;

                // Config based on type
                if (type === 'reviewer2') {
                    this.color = '#e74c3c';
                    this.hp = 3;
                    this.text = 'Rev2';
                    this.speed += 1;
                } else if (type === 'desk') {
                    this.color = '#7f8c8d';
                    this.hp = 5;
                    this.text = 'Desk';
                    this.radius = 35;
                    this.speed *= 0.5;
                } else {
                    this.color = '#95a5a6';
                    this.hp = 1;
                    this.text = 'Rev1';
                }
            }

            update() {
                // Chase player
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;

                // Collision with Player
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < this.radius + player.radius) {
                    if (player.shieldActive) {
                        // Bounce back?
                        this.x -= Math.cos(angle) * 10;
                        this.y -= Math.sin(angle) * 10;
                    } else {
                        player.hp -= 10;
                        this.markedForDeletion = true; // Explode on impact
                        updateHP();

                        // Screen shake effect?
                        // Simple flash
                        ctx.fillStyle = 'rgba(255,0,0,0.3)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 1;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.life = 1.0;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.05;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // Globals
        let player;
        let projectiles = [];
        let enemies = [];
        let particles = [];

        function init() {
            player = new Player();
            projectiles = [];
            enemies = [];
            particles = [];
            score = 0;
            wave = 1;
            updateHP();
            document.getElementById('score-val').innerText = score;
            document.getElementById('wave-val').innerText = wave;
        }

        function spawnEnemies() {
            if (frame % (60 * 2) === 0) { // Every 2 seconds
                const r = Math.random();
                let type = 'reviewer1';
                if (r > 0.7) type = 'reviewer2';
                if (r > 0.9) type = 'desk';

                enemies.push(new Enemy(type));
            }
        }

        function updateHP() {
            const bar = document.getElementById('hp-bar');
            bar.style.width = Math.max(0, player.hp) + '%';

            if (player.hp <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('go-msg').innerText = `You survived ${wave} waves. Score: ${score}`;
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            init();
            gameRunning = true;
            animate();
        }

        function resetGame() {
            document.getElementById('game-over').classList.add('hidden');
            init();
            gameRunning = true;
            animate();
        }

        function animate() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background grid
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }

            player.update();
            player.draw();

            projectiles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.markedForDeletion) projectiles.splice(index, 1);
            });

            enemies.forEach((e, eIndex) => {
                e.update();
                e.draw();

                // Projectile Collision
                projectiles.forEach((p, pIndex) => {
                    const dist = Math.hypot(p.x - e.x, p.y - e.y);
                    if (dist < e.radius + p.radius) {
                        // Hit
                        e.hp--;
                        p.markedForDeletion = true;

                        // Particles
                        for (let i = 0; i < 5; i++) particles.push(new Particle(e.x, e.y, e.color));

                        if (e.hp <= 0) {
                            e.markedForDeletion = true;
                            score += 100;
                            document.getElementById('score-val').innerText = score;
                        }
                    }
                });

                if (e.markedForDeletion) enemies.splice(eIndex, 1);
            });

            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(index, 1);
            });

            spawnEnemies();
            frame++;
            requestAnimationFrame(animate);
        }

    </script>
</body>

</html>